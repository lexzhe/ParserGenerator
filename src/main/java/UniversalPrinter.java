import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.stream.Collectors;

public class UniversalPrinter {

    private static String directory;

    public UniversalPrinter(String directory) {
        UniversalPrinter.directory = directory;
    }

    public static void makeSource(String fileName, String data) {
        String comment = "// This code is generated by AwesomeParserGenerator2000 (by @lexzhe)\n\n";
        String packageLine = "package " + directory + ";\n\n";
        String directoryName = "src\\main\\java\\" + directory;
        if ((new File(directoryName)).mkdir()){
            System.out.println("Directory <" + directoryName + "> was created");
        }

        String filename =  directoryName + "\\" + fileName + ".java";
        try {
            Files.createFile(Path.of(filename));
            System.out.println("File <" + filename + "> successfully created");
        } catch (FileAlreadyExistsException ex) {
            System.out.println("File <" + filename + "> already exists, rewriting");
        } catch (IOException e) {
            e.printStackTrace();
        }
        data = comment + packageLine + data;
        try (BufferedWriter writer = Files.newBufferedWriter(Path.of(filename))) {
            writer.write(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void printEnums(GrammarInfo grammarInfo) {
        List<GrammarInfo.Terminal> terminals = grammarInfo.getTerminals();
        String enumCases = terminals.stream().map(l -> l.getName().toUpperCase()).collect(Collectors.joining(","));
        String tempalte = """          
                public class Token {
                                
                    public Terminal terminal;
                                
                    public String text = "";
                                
                    public Token(Terminal terminal, String text) {
                        this.terminal = terminal;
                        this.text = text;
                    }
                                
                    public Token(Terminal terminal) {
                        this.terminal = terminal;
                    }
                                
                    @Override
                    public String toString() {
                        return terminal.name() + " : \\"" + text + "\\" ";
                    }
                }
                               
                                
                            
                """;
        makeSource("Token", tempalte);

        String enumTemplate = """
                enum Terminal{
                    %s, END
                }
                """;
        makeSource("Terminal", String.format(enumTemplate, enumCases));
    }

    public void printLexer(GrammarInfo info) {

        String lexerTemplate = """
                import java.util.*;
                import java.util.regex.Matcher;
                import java.util.regex.Pattern;
                                
                public class Lexer {
                                
                    private String data;
                                
                    private final Map<Pattern, Terminal> map;
                                
                    public Lexer(String data) {
                        this.data = data.replaceAll("[ \\n\\t]", "");
                        map = new LinkedHashMap<>();
                %s
                    }
                                
                    public List<Token> parseAll() {
                        List<Token> tokens = new ArrayList<>();
                        while (true) {
                            Token current = getToken();
                            tokens.add(current);
                            if (current.terminal == Terminal.END) {
                                return tokens;
                            }
                        }
                    }
                                
                    private Token getToken() {
                        if (data.isEmpty()) {
                            return new Token(Terminal.END);
                        }
                                
                        for (Map.Entry<Pattern, Terminal> entry : map.entrySet()) {
                            Pattern pat = entry.getKey();
                            Terminal terminal = entry.getValue();
                            Matcher matcher = pat.matcher(data);
                            if (matcher.matches() && !matcher.group().isEmpty()) {
                                String result = matcher.group(1);
                                int len = result.length();
                                if (len < data.length()) {
                                    data = data.substring(len);
                                } else {
                                    data = "";
                                }
                                return new Token(terminal, result);
                            }
                                
                        }
                                
                        return new Token(Terminal.END);
                    }
                                
                }
                                
                """;
        String filling = info.getTerminals()
                .stream()
                .map(terminal -> "        map.put(Pattern.compile(\"(" + terminal.regularExpression + ").*\"), Terminal." + terminal.getName() + ");\n")
                .collect(Collectors.joining());
        makeSource("Lexer", String.format(lexerTemplate, filling));
    }

    public void printTree(){
        String treeCode = """
                import java.util.ArrayList;
                import java.util.List;
                
                public class Tree {
                    String node;
                    String text = "";
                    private static int counter;
                    private int myCounter;
                
                    List<Tree> children = new ArrayList<>();
                
                    public Tree(String node) {
                        counter++;
                        myCounter = counter;
                        this.node = node;
                    }
                
                    public void add(Tree tree) {
                        children.add(tree);
                    }
                
                    public String toString() {
                        StringBuilder res = new StringBuilder(node);
                        res.append('[');
                        if (children != null) {
                            for (Tree child : children) {
                                res.append(child.toString());
                                res.append(", ");
                            }
                        }
                        res.append(']');
                        return res.toString();
                    }
                
                    public String toGraph() {
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append(myCounter).append(" [label = \\"").append(node).append("{ ").append(text).append(" }").append("\\"];\\n");
                        for (Tree ch : children) {
                            stringBuilder.append(myCounter).append(" -> ").append(ch.getCounter()).append(";\\n");
                            stringBuilder.append(ch.toGraph());
                        }
                        return stringBuilder.toString();
                    }
                
                    int getCounter() {
                        return this.myCounter;
                    }
                          
                }
                           
                """;
        makeSource("Tree", treeCode);
    }

    public void printParser(GrammarInfo info) {
        ParserPrinter pp = new ParserPrinter();
        makeSource("Parser", pp.createParser(info));
    }





}
