// This code is generated by AwesomeParserGenerator2000 (by @lexzhe)

package procalculator;

import java.util.*;

public class Parser {

    private int position = 0;
    private List<Token> data;

    public Parser(List<Token> data) {
        this.data = data;
    }

    public static class GrammarContext {
        public String text;
    }

    public static class ExprContext extends GrammarContext {
        private int localIndexRule = -1;

        public double res = 0.0;
        public TermContext term;
        public AddSubContext addSub;

        public Tree tree = new Tree("Expr");

        public void process() {
            if (term != null) {
                term.process();
            }
            if (addSub != null) {
                addSub.process();
            }
            switch (localIndexRule) {
                case 0:
                    res = term.res + addSub.res;
                    break;

            }


        }
    }

    public static class AddSubContext extends GrammarContext {
        private int localIndexRule = -1;

        public double res = 0.0;
        public TermContext term;
        public AddSubContext addSub;
        public MINUSContext MINUS;
        public PLUSContext PLUS;

        public Tree tree = new Tree("AddSub");

        public void process() {
            if (term != null) {
                term.process();
            }
            if (addSub != null) {
                addSub.process();
            }
            switch (localIndexRule) {
                case 0:
                    res = term.res + addSub.res;
                    break;
                case 1:
                    res = -term.res + addSub.res;
                    break;

            }


        }
    }

    public static class TermContext extends GrammarContext {
        private int localIndexRule = -1;

        public double res = 1.0;
        public ValueContext value;
        public MulDivContext mulDiv;

        public Tree tree = new Tree("Term");

        public void process() {
            if (value != null) {
                value.process();
            }
            if (mulDiv != null) {
                mulDiv.process();
            }
            switch (localIndexRule) {
                case 0:
                    res = value.res * mulDiv.res;
                    break;

            }


        }
    }

    public static class MulDivContext extends GrammarContext {
        private int localIndexRule = -1;

        public double res = 1.0;
        public DIVContext DIV;
        public MULTContext MULT;
        public ValueContext value;
        public MulDivContext mulDiv;

        public Tree tree = new Tree("MulDiv");

        public void process() {
            if (value != null) {
                value.process();
            }
            if (mulDiv != null) {
                mulDiv.process();
            }
            switch (localIndexRule) {
                case 0:
                    res = value.res * mulDiv.res;
                    break;
                case 1:
                    res = 1 / value.res * mulDiv.res;
                    break;

            }


        }
    }

    public static class ValueContext extends GrammarContext {
        private int localIndexRule = -1;

        public double res = 0.0;
        public RBContext RB;
        public NUMBERContext NUMBER;
        public LBContext LB;
        public ExprContext expr;
        public ValueContext value;
        public MINUSContext MINUS;

        public Tree tree = new Tree("Value");

        public void process() {
            if (expr != null) {
                expr.process();
            }
            if (value != null) {
                value.process();
            }
            switch (localIndexRule) {
                case 0:
                    res = Integer.parseInt(NUMBER.text);
                    break;
                case 1:
                    res = -value.res;
                    break;
                case 2:
                    res = expr.res;
                    break;

            }


        }
    }

    public static class NUMBERContext extends GrammarContext {
        public Tree tree = new Tree("NUMBER");
    }

    public static class PLUSContext extends GrammarContext {
        public Tree tree = new Tree("PLUS");
    }

    public static class MULTContext extends GrammarContext {
        public Tree tree = new Tree("MULT");
    }

    public static class DIVContext extends GrammarContext {
        public Tree tree = new Tree("DIV");
    }

    public static class MINUSContext extends GrammarContext {
        public Tree tree = new Tree("MINUS");
    }

    public static class LBContext extends GrammarContext {
        public Tree tree = new Tree("LB");
    }

    public static class RBContext extends GrammarContext {
        public Tree tree = new Tree("RB");
    }

    public ExprContext parseExpr() {
        ExprContext result = new ExprContext();
        switch (data.get(position).terminal) {
            case NUMBER:
                result = new ExprContext();
                result.localIndexRule = 0;
                result.term = parseTerm();
                result.tree.add(result.term.tree);
                result.addSub = parseAddSub();
                result.tree.add(result.addSub.tree);
                return result;
            case LB:
                result = new ExprContext();
                result.localIndexRule = 0;
                result.term = parseTerm();
                result.tree.add(result.term.tree);
                result.addSub = parseAddSub();
                result.tree.add(result.addSub.tree);
                return result;
            case MINUS:
                result = new ExprContext();
                result.localIndexRule = 0;
                result.term = parseTerm();
                result.tree.add(result.term.tree);
                result.addSub = parseAddSub();
                result.tree.add(result.addSub.tree);
                return result;

        }
        throw new IllegalStateException("Unexpected token " + data.get(position).terminal.name() + " at position: " + position);

    }

    public AddSubContext parseAddSub() {
        AddSubContext result = new AddSubContext();
        switch (data.get(position).terminal) {
            case PLUS:
                result = new AddSubContext();
                result.localIndexRule = 0;
                result.PLUS = parsePLUS();
                result.tree.add(result.PLUS.tree);
                result.term = parseTerm();
                result.tree.add(result.term.tree);
                result.addSub = parseAddSub();
                result.tree.add(result.addSub.tree);
                return result;
            case MINUS:
                result = new AddSubContext();
                result.localIndexRule = 1;
                result.MINUS = parseMINUS();
                result.tree.add(result.MINUS.tree);
                result.term = parseTerm();
                result.tree.add(result.term.tree);
                result.addSub = parseAddSub();
                result.tree.add(result.addSub.tree);
                return result;
            default:
                result = new AddSubContext();
                result.localIndexRule = 2;
                return result;

        }


    }

    public TermContext parseTerm() {
        TermContext result = new TermContext();
        switch (data.get(position).terminal) {
            case NUMBER:
                result = new TermContext();
                result.localIndexRule = 0;
                result.value = parseValue();
                result.tree.add(result.value.tree);
                result.mulDiv = parseMulDiv();
                result.tree.add(result.mulDiv.tree);
                return result;
            case LB:
                result = new TermContext();
                result.localIndexRule = 0;
                result.value = parseValue();
                result.tree.add(result.value.tree);
                result.mulDiv = parseMulDiv();
                result.tree.add(result.mulDiv.tree);
                return result;
            case MINUS:
                result = new TermContext();
                result.localIndexRule = 0;
                result.value = parseValue();
                result.tree.add(result.value.tree);
                result.mulDiv = parseMulDiv();
                result.tree.add(result.mulDiv.tree);
                return result;

        }
        throw new IllegalStateException("Unexpected token " + data.get(position).terminal.name() + " at position: " + position);

    }

    public MulDivContext parseMulDiv() {
        MulDivContext result = new MulDivContext();
        switch (data.get(position).terminal) {
            case DIV:
                result = new MulDivContext();
                result.localIndexRule = 1;
                result.DIV = parseDIV();
                result.tree.add(result.DIV.tree);
                result.value = parseValue();
                result.tree.add(result.value.tree);
                result.mulDiv = parseMulDiv();
                result.tree.add(result.mulDiv.tree);
                return result;
            case MULT:
                result = new MulDivContext();
                result.localIndexRule = 0;
                result.MULT = parseMULT();
                result.tree.add(result.MULT.tree);
                result.value = parseValue();
                result.tree.add(result.value.tree);
                result.mulDiv = parseMulDiv();
                result.tree.add(result.mulDiv.tree);
                return result;
            default:
                result = new MulDivContext();
                result.localIndexRule = 2;
                return result;

        }


    }

    public ValueContext parseValue() {
        ValueContext result = new ValueContext();
        switch (data.get(position).terminal) {
            case NUMBER:
                result = new ValueContext();
                result.localIndexRule = 0;
                result.NUMBER = parseNUMBER();
                result.tree.add(result.NUMBER.tree);
                return result;
            case LB:
                result = new ValueContext();
                result.localIndexRule = 2;
                result.LB = parseLB();
                result.tree.add(result.LB.tree);
                result.expr = parseExpr();
                result.tree.add(result.expr.tree);
                result.RB = parseRB();
                result.tree.add(result.RB.tree);
                return result;
            case MINUS:
                result = new ValueContext();
                result.localIndexRule = 1;
                result.MINUS = parseMINUS();
                result.tree.add(result.MINUS.tree);
                result.value = parseValue();
                result.tree.add(result.value.tree);
                return result;

        }
        throw new IllegalStateException("Unexpected token " + data.get(position).terminal.name() + " at position: " + position);

    }


    public NUMBERContext parseNUMBER() {
        NUMBERContext result = new NUMBERContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }

    public PLUSContext parsePLUS() {
        PLUSContext result = new PLUSContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }

    public MULTContext parseMULT() {
        MULTContext result = new MULTContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }

    public DIVContext parseDIV() {
        DIVContext result = new DIVContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }

    public MINUSContext parseMINUS() {
        MINUSContext result = new MINUSContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }

    public LBContext parseLB() {
        LBContext result = new LBContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }

    public RBContext parseRB() {
        RBContext result = new RBContext();
        result.tree.text = data.get(position).text;
        result.text = data.get(position++).text;
        return result;
    }


}
